# 1️⃣ Redis

인 메모리 데이터베이스 레디스를 처음 공부할 때 캐시, 성능 최적화, 빠른 속도 등의 다양한 이유로 많이 사용되고 있다고 들었다.

이때 Redis의 핵심 특징 중 하나로 싱글 스레드를 사용한다는 것을 들었는데, 그 이유에 대해 정리하고자 포스팅한다.


`Redis`가 싱글(단일) 스레드로 설계된 이유는 `성능 최적화`, `복잡성 감소`, `데이터 길관성 유지`를 위해서다.

단일 스레드 모델은 멀티 스레드 모델에 비해 설계와 구현이 간단하다.

멀티 스레드 환경에서 제일 문제가 되는 것이 `동시성 문제`(Race Condition, Dead Lock)인데, 이를 처리하기 위한 복잡한 동기화 메커니즘(락, 원자적 연산, 동기화 도구 등)이 필요하다.

하지만 단일 스레드 환경에서는 이를 모두 배제하고 사용할 수 있다는 큰 장점 때문에 채택된 것이다.

**🔥동시성 문제와 동기화 메커니즘을 정리하고 가자.**

# 2️⃣ 동시성 문제
### 1. 레이스 컨디션
**둘 이상의 스레드가 동시에 같은 메모리 공간을 읽고 쓰면서, 그 중 적어도 하나가 쓰기를 할 때 발생**

```java
int count = 0;

void increment() count++;
```

- 두 스레드가 동시에 increment()를 호출해서 count++를 수행하면 결과적으로 값이 한 번만 증가하는 문제 발생 가능출해서 count++를 수행하면 결과적으로 값이 한 번만 증가하는 문제 발생 가능

### 2. 데드락
**두 개 이상의 스레드가 서로가 가진 자원을 기다리느라 무한히 블로킹 상태에 빠지는 현상**

1. 스레드 A가 자원 a를 소유한 상태에서 자원 b를 요청
2. 스레드 B가 자원 b를 소유한 상태에서 자원 a를 요청
- 결과적으로 두 스레드가 멈춤

### 3. 기아 상태
**어떤 스레드가 계속해서 CPU 자원이나 락을 획득하지 못하고 우선순위에서 밀려 처리되지 못하는 현상**


## ✅ 동기화 문제 해결 방법
1. 뮤텍스 락, 스핀 락 사용
2. 원자적 연산 사용
3. `volatile`, `synchronize` 등 동기화 도구 사용

---

`Redis`는 주로 메모리 내에서 빠르게 수행되는 I/O 작업을 처리하는 인메모리 데이터베이스로 설계되어 매우 빠른 응답 시간을 제공한다.

단일 스레드 이벤트 루프를 사용함으로써 컨텍스트 스위칭에 소요되는 오버헤드를 최소화 할 수 있다.

> 또, 이벤트 기반 아키텍처를 채택하여 네트워크 요청을 효율적으로 처리한다.

단일 스레드 이벤트 루프는 `비동기`적으로 여러 클라이언트의 요청을 처리할 수 있으며, 이를 통해 높은 동시성을 구현할 수 있다.

멀티스레드 모델에서는 이러한 비동기 처리의 이점을 충분히 활용하기 어려울 수 있다.

![](https://velog.velcdn.com/images/alstjr971/post/cac62aa3-9654-4c95-a19d-664c9cd08fcf/image.png)


---

> Q. 레디스가 싱글 스레드 방식으로 동작한다는 것은 알겠는데, 그럼 데이터 쓰기 요청이 거의 동시에 들어왔을 때 동시성 처리를 하게 되면 레이스 컨디션과 같은 동기화 문제가 똑같이 발생하는거 아닌가?

답은 아니다. 우선 레디스는 싱글 스레드이기 때문에 병렬성 처리가 아닌 동시성 처리를 하는데, 동시성 처리의 모든 명령은 순차적으로 처리된다.

따라서 일반적인 동시성 문제가 거의 발생하지 않는다.

**🤔어떻게 동시성 문제를 회피❓**
레디스는 요청이 아무리 동시에 들어와도, `이벤트 루프`가 하나씩 순서대로 처리한다.

예를 들어 두 클라이언트가 동시에 INCR count 를 보냈을 때,
```
- 클라이언트 A 요청 도착 → 처리
- 클라이언트 B 요청 도착 → 큐에 들어갔다가 그 다음 처리
```
- 결국 count 값은 정확히 두 번 증가한다.

또, 레디스의 각 명령어는 `원자적`으로 실행된다.
